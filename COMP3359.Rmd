---
title: "COMP3359"
author: "Buntoro Reynard Verill & Andrianto Reno"
date: "3/11/2021"
output: 
  html_document:
    df_print: paged
    highlight: breezedark
    theme: cosmo
    toc: yes
    toc_float:
      collapsed: no
    css: assets/style.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align = "center", out.width = "80%")
options(scipen = 99)
```


<style>
body {
text-align: justify}
</style>

# Objectives

In this project, we aim to implement a proper movie recommendation system for customers using the data frame provided by netflix back in 2005 for its prize competition. Here, we will supplement suitable data pre-processing methods, data explorations, and data visualizations to ultimately aid the readers of this report in understanding the work-flow of our project, which finally leads to the development of our models, complemented with various error analysis, and suggestions for improvements.

# Libraries

Firstly, we import some of the necessary packages for the development of our project and deployment of suitable models.

```{r cars}
library(tidyverse)
library(ggplot2)
library(plotly)
library(glue)
library(scales)
library(recommenderlab)
library(dplyr)
library(recosystem)
library(tensorflow)
library(keras)
```

# Data Reading

In this section we will read the data into our IDE (i.e. in our case, to RStudio).

```{r pressure, echo=FALSE}
data <- read.csv("data_input/data.csv", header = FALSE)
data
```

```{r}
data <- data %>% rename(movie_id = V1,
                        customer_id = V2,
                        rating = V3,
                        date = V4
                        ) %>% 
  mutate(date = as.Date(date)) %>% 
  mutate(rating = as.factor(rating))

data %>% head()
```


```{r}
length(unique(data$movie_id))
```

```{r}
length(unique(data$customer_id))
```




```{r}
dim(data)
```

```{r}
colSums(is.na(data))
```

# Data Pre-processing {.tabset}


## Data inspection
```{r}
data_summary <- data %>% 
  group_by(rating)  %>% 
  count(rating) %>% 
  mutate(rating = as.factor(rating))
data_summary
```


```{r}
levels(data_summary$rating)
```


```{r}
label_percent <- label_dollar(suffix = '%' ,prefix = '')
data_summary <- data_summary %>% mutate(rating = as.factor(rating))
data_summary <- na.omit(data_summary)
data_summary$prob <- data_summary$n/sum(data_summary$n)*100
data_summary <- data_summary %>% 
  mutate(tooltip = glue("distribution: {label_percent(prob)}"))
data_summary
```

## Data Visualization

```{r}
data_sum_graph <- ggplot(data_summary, aes(x = rating, y = prob, text = tooltip, fill = prob)) +
  geom_col(position = "identity") +
  labs(title = "Probability Distribution of Movie Ratings",
       subtitle = paste("For data set 1 (", unique(data$movie_id), " movies, ", unique(data$customers), " customers, and ", nrow(data$rating), " ratings"),
       x = "Movie rating",
       y = "Probability") +
  scale_fill_gradient(low = "#e4333e", high = "#52171a") +
  theme_minimal() 
ggplotly(data_sum_graph, tooltip = c("text"))
```

# Model Training {.tabset}

```{r}
top_users <- data %>% 
  group_by(customer_id) %>% 
  count(rating)
top_users <- top_users %>% 
  group_by(customer_id) %>% 
  summarise(n = sum(n))
top_users <- top_users[order(-top_users$n), ] %>% 
  top_n(10000)
dim(top_users %>% top_n(10000))
```

```{r}
top_users %>% tail(10)
```

```{r}
top_movies <- data %>% 
  group_by(movie_id) %>% 
  count(rating)
top_movies <- top_movies %>% 
  group_by(movie_id) %>% 
  summarise(n = sum(n))
top_movies <- top_movies[order(-top_users$n), ] %>% 
  top_n(2000)
top_movies
```

```{r}
combined_light <- inner_join(data, top_users, by = "customer_id")
combined_light <- inner_join(combined_light, top_movies, by = "movie_id")

combined_light
```

```{r}
movie_titles <- read.csv("data_input/movie_titles.csv", header = FALSE)
movie_titles %>% head()
```
```{r}
movie_titles <- movie_titles %>% rename(movie_id = V1,
                                        year_released = V2,
                                        title = V3)

combined_light <- inner_join(combined_light, movie_titles %>% mutate_at(c("movie_id", "year_released"), as.numeric), by = "movie_id")
combined_light %>% head()
```


```{r}
dim(combined_light)
```


```{r}
length(unique(combined_light$customer_id))
```

```{r}
n_movies <- combined_light %>% select(movie_id) %>% distinct() %>% nrow()
n_users <- combined_light %>% select(customer_id) %>% distinct() %>% nrow()
```

```{r}
dense_movies <- combined_light %>% select(movie_id) %>% distinct() %>% rowid_to_column()
combined_light <- combined_light %>% inner_join(dense_movies) %>% rename(movie_id_dense = rowid)
dense_customer <- combined_light %>% select(customer_id) %>% distinct %>% rowid_to_column()
combined_light <- combined_light %>% inner_join(dense_customer) %>% rename(customer_id_dense = rowid)
```

```{r}
set.seed(3359)

index <- sample(1:nrow(combined_light), nrow(combined_light)*0.9)

x_train <- combined_light %>% select(c(customer_id_dense, movie_id_dense)) %>% as.matrix()
x_train %>% head()

y_train <- combined_light %>% pull(rating)
```

```{r}
dim(x_train)
```


```{r}
embedding_dim <- 64

input_users <- layer_input(shape = 1, name = "users")
input_movies <- layer_input(shape = 1, name = "movies")

user_embeddings <- input_users %>% 
  layer_embedding(
    input_dim = n_users+1,
    output_dim = embedding_dim,
    name = "user_embeddings"
  ) 

movie_embeddings <- input_movies %>% 
  layer_embedding(
    input_dim = n_movies+1,
    output_dim = embedding_dim,
    name = "movie_embeddings"
  ) 

```

```{r}
dot <- layer_dot(
  inputs = list(user_embeddings, movie_embeddings),
  axes = 2,
  name = "dot_product"
  )

pred <- dot %>% layer_dense(
  units = 1, 
  activation = "relu",
  name = "rating_prediction"
  )
```

```{r}
model <- keras_model(inputs = c(input_users, input_movies), outputs = pred)

model %>% compile(
  optimizer = "rmsprop",
  loss = "mse",
  metric = "mae"
)

summary(model)
```


```{r}
history <- model %>% fit(
  x = list(
    x_train[, "customer_id_dense", drop = FALSE],
    x_train[, "movie_id_dense", drop = FALSE]
  ),
  y = y_train,
  epochs = 5,
  batch_size = 32, 
  validation_split = 0.2,
  callbacks = list(callback_early_stopping(patience = 2))
)
```


```{r}
plot(history)
```


```{r}
movie_embeddings <- model %>%
  get_layer("movie_embeddings") %>% 
  get_weights() %>%
  .[[1]] 
dim(movie_embeddings)
movie_embeddings <- movie_embeddings[1:2000, ]
```


```{r}
titles <- combined_light %>%
  select(movie_id_dense, title) %>%
  distinct() %>%
  arrange(movie_id_dense) %>%
  mutate(title = title %>% str_remove("\\(.+\\)") %>% str_trim())
dim(titles)
row.names(movie_embeddings) <- titles$title

movie_embeddings[1:10, 1:4]
```

```{r}
n_words_to_plot <- 200

tsne <- Rtsne::Rtsne(
  X = movie_embeddings[1:n_words_to_plot,], 
  perplexity = 30, 
  pca = FALSE
  )

p <- tsne$Y %>%
  as.data.frame() %>%
  mutate(word = row.names(movie_embeddings)[1:n_words_to_plot]) %>%
  ggplot(aes(x = V1, y = V2, label = word)) + 
  geom_text(size = 3)

plotly::ggplotly(p)
```

```{r}
original_customer_id <- 1000
new_customer_id <- original_customer_id - 1

# get movies watched by our user
movies_watched <- combined_light %>%
  filter(customer_id_dense == new_customer_id) %>% 
  pull(movie_id_dense)

# get all available movies
all_movies <- combined_light %>% 
  distinct(movie_id_dense) %>%
  pull()

# identify movies not watched
movies_not_watched <- setdiff(all_movies, movies_watched)

movie_options <- combined_light %>%
  filter(movie_id_dense %in% movies_not_watched) %>%
  distinct(movie_id_dense, title)

movie_options
```

```{r}
customer_options <- expand.grid(
  user_id = new_customer_id, 
  movie_id_dense= movies_not_watched
  ) %>%
  as.matrix()

head(customer_options)
```

```{r}
inputs <- list(
  customer_options[, "user_id", drop = FALSE],
  customer_options[, "movie_id_dense", drop = FALSE]
  )

pred <- model %>% predict(inputs)

head(pred)
```

```{r}
combined_light %>% 
  filter(movie_id_dense %in% movies_watched) %>%
  distinct(movie_id_dense, title)
```

```{r}
customer_options %>%
  as_tibble() %>%
  mutate(predictions = as.vector(pred)) %>%
  left_join(movie_options, by = "movie_id_dense") %>%
  arrange(desc(predictions))
```

```{r}
saveRDS(model, "model_netflix.rds")
```

## Collaborative Filtering

```{r}

```


## R Pearson's Correlation

